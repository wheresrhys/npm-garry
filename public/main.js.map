{"version":3,"sources":["webpack:///webpack/bootstrap 4499dcef37abbd8a6d28","webpack:///./client/main.js","webpack:///./~/preact/dist/preact.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACtCA;;AAEA,KAAI,MAAM,mCAAV;AACA,OAAM,SAAS,GAAG,GAAH,CAAf;;AAGA,OAAM,IAAN,2BAA6B;AACzB,iBAAY,EAAC,IAAD,EAAO,GAAP,EAAZ,EAAyB;AACrB;AACA,aAAI,GAAJ,EAAS;AACR,oBAAO,IAAP,CAAY,SAAZ,EAAuB,KAAK,SAAL,CAAe,cAAf,CAAvB;AACJ,oBAAO,EAAP,CAAU,MAAV,EAAkB,QAAQ;AACtB,sBAAK,QAAL,CAAc,EAAC,MAAM,IAAP,EAAd;AACH,cAFD;AAGA,kBAAK,KAAL,CAAW,IAAX,GAAkB,EAAC,MAAM,eAAe,IAAtB,EAA4B,cAAc,EAA1C,EAAlB;AACA,UANG,MAMG;AACN,kBAAK,KAAL,CAAW,IAAX,GAAkB,IAAlB;AACA;AACA;;AAGD,cAAS;AACR,eAAM,OAAO,KAAK,KAAL,CAAW,IAAX,IAAmB,KAAK,KAAL,CAAW,IAA3C;AACG,gBAAO;AAAA;AAAA,eAAK,SAAO,UAAU,KAAK,QAAL,GAAgB,WAAhB,GAA8B,aAAxC,CAAZ;AACb;AAAA;AAAA;AAAG;AAAA;AAAA,uBAAG,MAAM,sBAAsB,KAAK,IAApC;AAA4C,0BAAK;AAAjD,kBAAH;AAAA;AACA;AAAA;AAAA,uBAAG,MAAM,sBAAuB,KAAK,IAA5B,GAAmC,WAAnC,GAAiD,KAAK,OAA/D;AAA2E,0BAAK;AAAhF,kBADA;AAAA;AAEA;AAAA;AAAA,uBAAG,MAAM,sBAAuB,KAAK,IAA5B,GAAmC,WAAnC,GAAiD,KAAK,KAA/D;AAAyE,0BAAK;AAA9E;AAFA,cADa;AAKb;AAAA;AAAA;AACE,wBAAO,IAAP,CAAY,KAAK,YAAjB,EAA+B,GAA/B,CAAmC,OACpC;AAAA;AAAA;AACC,oCAAC,IAAD,IAAM,MAAM,KAAK,YAAL,CAAkB,GAAlB,CAAZ;AADD,kBADC;AADF;AALa,UAAP;AAaH;AA9BwB;;AAkC7B,qBAAO,eAAC,IAAD,IAAM,KAAI,MAAV,GAAP,EAA2B,SAAS,cAAT,CAAwB,MAAxB,CAA3B,E;;;;;;ACxCA;AACA,wJAA4M;AAC5M,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA,4CAA2C,qBAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,gCAA+B,SAAS;AACxC;AACA;AACA,+CAA8C;AAC9C,wCAAuC,gBAAgB;AACvD;AACA;AACA,8FAA6F;AAC7F;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,4BAA2B,qBAAqB,8CAA8C;AAC9F;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yIAAwI;AACxI;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT,6DAA4D;AAC5D;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,mHAAkH,iCAAiC,iJAAiJ;AACpS;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA,8HAA6H;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA,kNAAiN;AACjN;AACA;AACA;AACA;AACA;AACA;AACA,8FAA6F;AAC7F,iCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,kCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,4CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kIAAiI;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+IAA8I;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAqH;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAkE;AAClE;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,mC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4499dcef37abbd8a6d28\n **/","import { h, render, Component } from 'preact';\n\nvar nsp = '/api/package/${ctx.query.package}'\nconst socket = io('/');\n\n\nclass Tree extends Component {\n    constructor({tree, top}) {\n        super();\n        if (top) {\n\t        socket.emit('package', JSON.stringify(packageDetails))\n\t\t\t\t\tsocket.on('tree', data => {\n\t\t\t\t\t    this.setState({tree: data});\n\t\t\t\t\t});\n\t\t\t\t\tthis.state.tree = {name: packageDetails.name, dependencies: {}}\n\t\t\t\t} else {\n\t\t\t\t\tthis.state.tree = tree;\n\t\t\t\t}\n    }\n\n\n    render() {\n    \tconst tree = this.props.tree || this.state.tree;\n        return <div class={\"tree\" + (tree.complete ? \" complete\" : \" incomplete\")} >\n  <p><a href={\"/package?package=\" + tree.name}>{ tree.name }</a>,\n  <a href={\"/package?package=\"  + tree.name + \"&version=\" + tree.version }>{ tree.version }</a>,\n  <a href={\"/package?package=\"  + tree.name + \"&version=\" + tree.range }>{ tree.range }</a></p>\n\n  <ul>\n  { Object.keys(tree.dependencies).map(dep => (\n\t\t\t<li>\n\t\t\t\t<Tree tree={tree.dependencies[dep]} />\n\t\t\t</li>\n\t\t)) }\n  </ul>\n</div>\n    }\n}\n\n\nrender(<Tree top=\"true\"/>, document.getElementById('tree'));\n\n\n/** WEBPACK FOOTER **\n ** ./client/main.js\n **/","!function(global, factory) {\n    'object' == typeof exports && 'undefined' != typeof module ? factory(exports) : 'function' == typeof define && define.amd ? define([ 'exports' ], factory) : factory(global.preact = global.preact || {});\n}(this, function(exports) {\n    function VNode(nodeName, attributes, children) {\n        this.nodeName = nodeName;\n        this.attributes = attributes;\n        this.children = children;\n        this.key = attributes && attributes.key;\n    }\n    function extend(obj, props) {\n        if (props) for (var i in props) if (void 0 !== props[i]) obj[i] = props[i];\n        return obj;\n    }\n    function clone(obj) {\n        return extend({}, obj);\n    }\n    function delve(obj, key) {\n        for (var p = key.split('.'), i = 0; i < p.length && obj; i++) obj = obj[p[i]];\n        return obj;\n    }\n    function toArray(obj, offset) {\n        return [].slice.call(obj, offset);\n    }\n    function isFunction(obj) {\n        return 'function' == typeof obj;\n    }\n    function isString(obj) {\n        return 'string' == typeof obj;\n    }\n    function empty(x) {\n        return void 0 === x || null === x;\n    }\n    function falsey(value) {\n        return value === !1 || empty(value);\n    }\n    function hashToClassName(c) {\n        var str = '';\n        for (var prop in c) if (c[prop]) {\n            if (str) str += ' ';\n            str += prop;\n        }\n        return str;\n    }\n    function h(nodeName, attributes, firstChild) {\n        var children, arr, lastSimple, len = arguments.length;\n        if (len > 2) {\n            var type = typeof firstChild;\n            if (3 === len && 'object' !== type && 'function' !== type) {\n                if (!falsey(firstChild)) children = [ String(firstChild) ];\n            } else {\n                children = [];\n                for (var i = 2; i < len; i++) {\n                    var _p = arguments[i];\n                    if (!falsey(_p)) {\n                        if (_p.join) arr = _p; else (arr = SHARED_TEMP_ARRAY)[0] = _p;\n                        for (var j = 0; j < arr.length; j++) {\n                            var child = arr[j], simple = !(falsey(child) || isFunction(child) || child instanceof VNode);\n                            if (simple && !isString(child)) child = String(child);\n                            if (simple && lastSimple) children[children.length - 1] += child; else if (!falsey(child)) {\n                                children.push(child);\n                                lastSimple = simple;\n                            }\n                        }\n                    } else ;\n                }\n            }\n        } else if (attributes && attributes.children) return h(nodeName, attributes, attributes.children);\n        if (attributes) {\n            if (attributes.children) delete attributes.children;\n            if (!isFunction(nodeName)) {\n                if ('className' in attributes) {\n                    attributes.class = attributes.className;\n                    delete attributes.className;\n                }\n                lastSimple = attributes.class;\n                if (lastSimple && !isString(lastSimple)) attributes.class = hashToClassName(lastSimple);\n            }\n        }\n        var p = new VNode(nodeName, attributes || void 0, children);\n        if (options.vnode) options.vnode(p);\n        return p;\n    }\n    function cloneElement(vnode, props) {\n        return h(vnode.nodeName, extend(clone(vnode.attributes), props), arguments.length > 2 ? toArray(arguments, 2) : vnode.children);\n    }\n    function createLinkedState(component, key, eventPath) {\n        var path = key.split('.'), p0 = path[0];\n        return function(e) {\n            var _component$setState;\n            var v, i, t = e && e.currentTarget || this, s = component.state, obj = s;\n            if (isString(eventPath)) {\n                v = delve(e, eventPath);\n                if (empty(v) && (t = t._component)) v = delve(t, eventPath);\n            } else v = t.nodeName ? (t.nodeName + t.type).match(/^input(check|rad)/i) ? t.checked : t.value : e;\n            if (isFunction(v)) v = v.call(t);\n            if (path.length > 1) {\n                for (i = 0; i < path.length - 1; i++) obj = obj[path[i]] || (obj[path[i]] = {});\n                obj[path[i]] = v;\n                v = s[p0];\n            }\n            component.setState((_component$setState = {}, _component$setState[p0] = v, _component$setState));\n        };\n    }\n    function enqueueRender(component) {\n        if (1 === items.push(component)) (options.debounceRendering || defer)(rerender);\n    }\n    function rerender() {\n        if (items.length) {\n            var p, currentItems = items;\n            items = itemsOffline;\n            itemsOffline = currentItems;\n            while (p = currentItems.pop()) if (p._dirty) renderComponent(p);\n        }\n    }\n    function isFunctionalComponent(vnode) {\n        var nodeName = vnode && vnode.nodeName;\n        return nodeName && isFunction(nodeName) && !(nodeName.prototype && nodeName.prototype.render);\n    }\n    function buildFunctionalComponent(vnode, context) {\n        return vnode.nodeName(getNodeProps(vnode), context || EMPTY);\n    }\n    function ensureNodeData(node, data) {\n        return node[ATTR_KEY] || (node[ATTR_KEY] = data || {});\n    }\n    function getNodeType(node) {\n        if (node instanceof Text) return 3;\n        if (node instanceof Element) return 1; else return 0;\n    }\n    function removeNode(node) {\n        var p = node.parentNode;\n        if (p) p.removeChild(node);\n    }\n    function setAccessor(node, name, value, old, isSvg) {\n        ensureNodeData(node)[name] = value;\n        if ('key' !== name && 'children' !== name && 'innerHTML' !== name) if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {\n            if (!value || isString(value) || isString(old)) node.style.cssText = value || '';\n            if (value && 'object' == typeof value) {\n                if (!isString(old)) for (var i in old) if (!(i in value)) node.style[i] = '';\n                for (var i in value) node.style[i] = 'number' == typeof value[i] && !NON_DIMENSION_PROPS[i] ? value[i] + 'px' : value[i];\n            }\n        } else if ('dangerouslySetInnerHTML' === name) {\n            if (value) node.innerHTML = value.__html;\n        } else if (name.match(/^on/i)) {\n            var l = node._listeners || (node._listeners = {});\n            name = toLowerCase(name.substring(2));\n            if (value) {\n                if (!l[name]) node.addEventListener(name, eventProxy);\n            } else if (l[name]) node.removeEventListener(name, eventProxy);\n            l[name] = value;\n        } else if ('type' !== name && !isSvg && name in node) {\n            setProperty(node, name, empty(value) ? '' : value);\n            if (falsey(value)) node.removeAttribute(name);\n        } else {\n            var ns = isSvg && name.match(/^xlink\\:?(.+)/);\n            if (falsey(value)) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1])); else node.removeAttribute(name); else if ('object' != typeof value && !isFunction(value)) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1]), value); else node.setAttribute(name, value);\n        }\n    }\n    function setProperty(node, name, value) {\n        try {\n            node[name] = value;\n        } catch (e) {}\n    }\n    function eventProxy(e) {\n        return this._listeners[e.type](options.event && options.event(e) || e);\n    }\n    function getRawNodeAttributes(node) {\n        var attrs = {};\n        for (var i = node.attributes.length; i--; ) attrs[node.attributes[i].name] = node.attributes[i].value;\n        return attrs;\n    }\n    function isSameNodeType(node, vnode) {\n        if (isString(vnode)) return 3 === getNodeType(node);\n        if (isString(vnode.nodeName)) return isNamedNode(node, vnode.nodeName);\n        if (isFunction(vnode.nodeName)) return node._componentConstructor === vnode.nodeName || isFunctionalComponent(vnode); else ;\n    }\n    function isNamedNode(node, nodeName) {\n        return node.normalizedNodeName === nodeName || toLowerCase(node.nodeName) === toLowerCase(nodeName);\n    }\n    function getNodeProps(vnode) {\n        var defaultProps = vnode.nodeName.defaultProps, props = clone(defaultProps || vnode.attributes);\n        if (defaultProps) extend(props, vnode.attributes);\n        if (vnode.children) props.children = vnode.children;\n        return props;\n    }\n    function collectNode(node) {\n        cleanNode(node);\n        var name = toLowerCase(node.nodeName), list = nodes[name];\n        if (list) list.push(node); else nodes[name] = [ node ];\n    }\n    function createNode(nodeName, isSvg) {\n        var name = toLowerCase(nodeName), node = nodes[name] && nodes[name].pop() || (isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName));\n        ensureNodeData(node);\n        node.normalizedNodeName = name;\n        return node;\n    }\n    function cleanNode(node) {\n        removeNode(node);\n        if (1 === getNodeType(node)) {\n            ensureNodeData(node, getRawNodeAttributes(node));\n            node._component = node._componentConstructor = null;\n        }\n    }\n    function flushMounts() {\n        var c;\n        while (c = mounts.pop()) if (c.componentDidMount) c.componentDidMount();\n    }\n    function diff(dom, vnode, context, mountAll, parent, rootComponent, nextSibling) {\n        diffLevel++;\n        var ret = idiff(dom, vnode, context, mountAll, rootComponent);\n        if (parent && ret.parentNode !== parent) parent.insertBefore(ret, nextSibling || null);\n        if (!--diffLevel) flushMounts();\n        return ret;\n    }\n    function idiff(dom, vnode, context, mountAll, rootComponent) {\n        var originalAttributes = vnode && vnode.attributes;\n        while (isFunctionalComponent(vnode)) vnode = buildFunctionalComponent(vnode, context);\n        if (empty(vnode)) {\n            vnode = '';\n            if (rootComponent) {\n                if (dom) {\n                    if (8 === dom.nodeType) return dom;\n                    collectNode(dom);\n                }\n                return document.createComment(vnode);\n            }\n        }\n        if (isString(vnode)) {\n            if (dom) {\n                if (3 === getNodeType(dom) && dom.parentNode) {\n                    dom.nodeValue = vnode;\n                    return dom;\n                }\n                collectNode(dom);\n            }\n            return document.createTextNode(vnode);\n        }\n        var svgMode, out = dom, nodeName = vnode.nodeName;\n        if (isFunction(nodeName)) return buildComponentFromVNode(dom, vnode, context, mountAll);\n        if (!isString(nodeName)) nodeName = String(nodeName);\n        svgMode = 'svg' === toLowerCase(nodeName);\n        if (svgMode) isSvgMode = !0;\n        if (!dom) out = createNode(nodeName, isSvgMode); else if (!isNamedNode(dom, nodeName)) {\n            out = createNode(nodeName, isSvgMode);\n            while (dom.firstChild) out.appendChild(dom.firstChild);\n            recollectNodeTree(dom);\n        }\n        if (vnode.children && 1 === vnode.children.length && 'string' == typeof vnode.children[0] && 1 === out.childNodes.length && out.firstChild instanceof Text) out.firstChild.nodeValue = vnode.children[0]; else if (vnode.children || out.firstChild) innerDiffNode(out, vnode.children, context, mountAll);\n        diffAttributes(out, vnode.attributes);\n        if (originalAttributes && originalAttributes.ref) (out[ATTR_KEY].ref = originalAttributes.ref)(out);\n        if (svgMode) isSvgMode = !1;\n        return out;\n    }\n    function innerDiffNode(dom, vchildren, context, mountAll) {\n        var j, c, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren && vchildren.length;\n        if (len) for (var i = 0; i < len; i++) {\n            var _child = originalChildren[i], key = vlen ? (c = _child._component) ? c.__key : (c = _child[ATTR_KEY]) ? c.key : null : null;\n            if (key || 0 === key) {\n                keyedLen++;\n                keyed[key] = _child;\n            } else children[childrenLen++] = _child;\n        }\n        if (vlen) for (var i = 0; i < vlen; i++) {\n            vchild = vchildren[i];\n            child = null;\n            if (keyedLen && vchild.attributes) {\n                var key = vchild.key;\n                if (!empty(key) && key in keyed) {\n                    child = keyed[key];\n                    keyed[key] = void 0;\n                    keyedLen--;\n                }\n            }\n            if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) {\n                c = children[j];\n                if (c && isSameNodeType(c, vchild)) {\n                    child = c;\n                    children[j] = void 0;\n                    if (j === childrenLen - 1) childrenLen--;\n                    if (j === min) min++;\n                    break;\n                }\n            }\n            child = idiff(child, vchild, context, mountAll);\n            if (child !== originalChildren[i]) dom.insertBefore(child, originalChildren[i] || null);\n        }\n        if (keyedLen) for (var i in keyed) if (keyed[i]) children[min = childrenLen++] = keyed[i];\n        if (min < childrenLen) removeOrphanedChildren(children);\n    }\n    function removeOrphanedChildren(children, unmountOnly) {\n        for (var i = children.length; i--; ) {\n            var child = children[i];\n            if (child) recollectNodeTree(child, unmountOnly);\n        }\n    }\n    function recollectNodeTree(node, unmountOnly) {\n        var component = node._component;\n        if (component) unmountComponent(component, !unmountOnly); else {\n            if (node[ATTR_KEY] && node[ATTR_KEY].ref) node[ATTR_KEY].ref(null);\n            if (!unmountOnly) collectNode(node);\n            if (node.childNodes && node.childNodes.length) removeOrphanedChildren(node.childNodes, unmountOnly);\n        }\n    }\n    function diffAttributes(dom, attrs) {\n        var old = dom[ATTR_KEY] || getRawNodeAttributes(dom);\n        for (var _name in old) if (!(attrs && _name in attrs)) setAccessor(dom, _name, null, old[_name], isSvgMode);\n        if (attrs) for (var _name2 in attrs) if (!(_name2 in old) || attrs[_name2] != old[_name2] || ('value' === _name2 || 'checked' === _name2) && attrs[_name2] != dom[_name2]) setAccessor(dom, _name2, attrs[_name2], old[_name2], isSvgMode);\n    }\n    function collectComponent(component) {\n        var name = component.constructor.name, list = components[name];\n        if (list) list.push(component); else components[name] = [ component ];\n    }\n    function createComponent(Ctor, props, context) {\n        var inst = new Ctor(props, context), list = components[Ctor.name];\n        inst.props = props;\n        inst.context = context;\n        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {\n            inst.nextBase = list[i].nextBase;\n            list.splice(i, 1);\n            break;\n        }\n        return inst;\n    }\n    function triggerComponentRender(component) {\n        if (!component._dirty) {\n            component._dirty = !0;\n            enqueueRender(component);\n        }\n    }\n    function setComponentProps(component, props, opts, context, mountAll) {\n        var b = component.base;\n        if (!component._disableRendering) {\n            component._disableRendering = !0;\n            if (component.__ref = props.ref) delete props.ref;\n            if (component.__key = props.key) delete props.key;\n            if (empty(b) || mountAll) {\n                if (component.componentWillMount) component.componentWillMount();\n            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);\n            if (context && context !== component.context) {\n                if (!component.prevContext) component.prevContext = component.context;\n                component.context = context;\n            }\n            if (!component.prevProps) component.prevProps = component.props;\n            component.props = props;\n            component._disableRendering = !1;\n            if (0 !== opts) if (1 === opts || options.syncComponentUpdates !== !1 || !b) renderComponent(component, 1, mountAll); else triggerComponentRender(component);\n            if (component.__ref) component.__ref(component);\n        }\n    }\n    function renderComponent(component, opts, mountAll) {\n        if (!component._disableRendering) {\n            var skip, rendered, props = component.props, state = component.state, context = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context, isUpdate = component.base, initialBase = isUpdate || component.nextBase, baseParent = initialBase && initialBase.parentNode, initialComponent = initialBase && initialBase._component, initialChildComponent = component._component;\n            if (isUpdate) {\n                component.props = previousProps;\n                component.state = previousState;\n                component.context = previousContext;\n                if (2 !== opts && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === !1) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);\n                component.props = props;\n                component.state = state;\n                component.context = context;\n            }\n            component.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n            component._dirty = !1;\n            if (!skip) {\n                if (component.render) rendered = component.render(props, state, context);\n                if (component.getChildContext) context = extend(clone(context), component.getChildContext());\n                while (isFunctionalComponent(rendered)) rendered = buildFunctionalComponent(rendered, context);\n                var toUnmount, base, childComponent = rendered && rendered.nodeName;\n                if (isFunction(childComponent) && childComponent.prototype.render) {\n                    var inst = initialChildComponent, childProps = getNodeProps(rendered);\n                    if (inst && inst.constructor === childComponent) setComponentProps(inst, childProps, 1, context); else {\n                        toUnmount = inst;\n                        inst = createComponent(childComponent, childProps, context);\n                        inst._parentComponent = component;\n                        component._component = inst;\n                        setComponentProps(inst, childProps, 0, context);\n                        renderComponent(inst, 1);\n                    }\n                    base = inst.base;\n                } else {\n                    var cbase = initialBase;\n                    toUnmount = initialChildComponent;\n                    if (toUnmount) cbase = component._component = null;\n                    if (initialBase || 1 === opts) {\n                        if (cbase) cbase._component = null;\n                        base = diff(cbase, rendered, context, mountAll || !isUpdate, baseParent, !0, initialBase && initialBase.nextSibling);\n                    }\n                }\n                if (initialBase && base !== initialBase) if (!toUnmount && initialComponent === component && !initialChildComponent && initialBase.parentNode) {\n                    initialBase._component = null;\n                    recollectNodeTree(initialBase);\n                }\n                if (toUnmount) unmountComponent(toUnmount, !0);\n                component.base = base;\n                if (base) {\n                    var componentRef = component, t = component;\n                    while (t = t._parentComponent) componentRef = t;\n                    base._component = componentRef;\n                    base._componentConstructor = componentRef.constructor;\n                }\n            }\n            if (!isUpdate || mountAll) {\n                mounts.unshift(component);\n                if (!diffLevel) flushMounts();\n            } else if (!skip && component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);\n            var fn, cb = component._renderCallbacks;\n            if (cb) while (fn = cb.pop()) fn.call(component);\n            return rendered;\n        }\n    }\n    function buildComponentFromVNode(dom, vnode, context, mountAll) {\n        var c = dom && dom._component, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);\n        while (c && !isOwner && (c = c._parentComponent)) isOwner = c.constructor === vnode.nodeName;\n        if (isOwner && (!mountAll || c._component)) {\n            setComponentProps(c, props, 3, context, mountAll);\n            dom = c.base;\n        } else {\n            if (c && !isDirectOwner) {\n                unmountComponent(c, !0);\n                dom = oldDom = null;\n            }\n            c = createComponent(vnode.nodeName, props, context);\n            if (dom && !c.nextBase) c.nextBase = dom;\n            setComponentProps(c, props, 1, context, mountAll);\n            dom = c.base;\n            if (oldDom && dom !== oldDom) {\n                oldDom._component = null;\n                recollectNodeTree(oldDom);\n            }\n        }\n        return dom;\n    }\n    function unmountComponent(component, remove) {\n        var base = component.base;\n        component._disableRendering = !0;\n        if (component.componentWillUnmount) component.componentWillUnmount();\n        component.base = null;\n        var inner = component._component;\n        if (inner) unmountComponent(inner, remove); else if (base) {\n            if (base[ATTR_KEY] && base[ATTR_KEY].ref) base[ATTR_KEY].ref(null);\n            component.nextBase = base;\n            if (remove) {\n                removeNode(base);\n                collectComponent(component);\n            }\n            removeOrphanedChildren(base.childNodes, !remove);\n        }\n        if (component.__ref) component.__ref(null);\n        if (component.componentDidUnmount) component.componentDidUnmount();\n    }\n    function Component(props, context) {\n        this._dirty = !0;\n        this._disableRendering = !1;\n        this.prevState = this.prevProps = this.prevContext = this.base = this.nextBase = this._parentComponent = this._component = this.__ref = this.__key = this._linkedStates = this._renderCallbacks = null;\n        this.context = context;\n        this.props = props;\n        this.state = this.getInitialState && this.getInitialState() || {};\n    }\n    function render(vnode, parent, merge) {\n        return diff(merge, vnode, {}, !1, parent);\n    }\n    var lcCache = {};\n    var toLowerCase = function(s) {\n        return lcCache[s] || (lcCache[s] = s.toLowerCase());\n    };\n    var resolved = 'undefined' != typeof Promise && Promise.resolve();\n    var defer = resolved ? function(f) {\n        resolved.then(f);\n    } : setTimeout;\n    var options = {\n        vnode: empty\n    };\n    var SHARED_TEMP_ARRAY = [];\n    var EMPTY = {};\n    var ATTR_KEY = 'undefined' != typeof Symbol ? Symbol.for('preactattr') : '__preactattr_';\n    var NON_DIMENSION_PROPS = {\n        boxFlex: 1,\n        boxFlexGroup: 1,\n        columnCount: 1,\n        fillOpacity: 1,\n        flex: 1,\n        flexGrow: 1,\n        flexPositive: 1,\n        flexShrink: 1,\n        flexNegative: 1,\n        fontWeight: 1,\n        lineClamp: 1,\n        lineHeight: 1,\n        opacity: 1,\n        order: 1,\n        orphans: 1,\n        strokeOpacity: 1,\n        widows: 1,\n        zIndex: 1,\n        zoom: 1\n    };\n    var items = [];\n    var itemsOffline = [];\n    var nodes = {};\n    var mounts = [];\n    var diffLevel = 0;\n    var isSvgMode = !1;\n    var components = {};\n    extend(Component.prototype, {\n        linkState: function(key, eventPath) {\n            var c = this._linkedStates || (this._linkedStates = {}), cacheKey = key + '|' + eventPath;\n            return c[cacheKey] || (c[cacheKey] = createLinkedState(this, key, eventPath));\n        },\n        setState: function(state, callback) {\n            var s = this.state;\n            if (!this.prevState) this.prevState = clone(s);\n            extend(s, isFunction(state) ? state(s, this.props) : state);\n            if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n            triggerComponentRender(this);\n        },\n        forceUpdate: function() {\n            renderComponent(this, 2);\n        },\n        render: function() {\n            return null;\n        }\n    });\n    exports.h = h;\n    exports.cloneElement = cloneElement;\n    exports.Component = Component;\n    exports.render = render;\n    exports.rerender = rerender;\n    exports.options = options;\n});\n//# sourceMappingURL=preact.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/preact/dist/preact.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}